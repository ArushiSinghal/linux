#!/bin/bash
#
# Translate stack dump function offsets.
#
# addr2line doesn't work with KASLR addresses.  This works similarly to
# addr2line, but instead takes the 'func+0x123' format as input:
#
#   $ scripts/faddr2line vmlinux meminfo_proc_show+0x5/0x1b0
#   fs/proc/meminfo.c:27
#
# It also supports duplicate symbols:
#
#   $ scripts/faddr2line vmlinux raw_ioctl+0x5
#   drivers/char/raw.c:122
#   net/ipv4/raw.c:876

set -o errexit
set -o nounset

usage() {
	echo "usage: faddr2line <object file> <func+offset>" >&2
	exit 1
}

die() {
	echo "ERROR: $1" >&2
	exit 1
}

[[ $# != 2 ]] && usage

objfile=$1
[[ ! -f $objfile ]] && die "can't find objfile $objfile"

func_offset=$2
func=${func_offset%+*}
offset=${func_offset#*+}
offset=${offset%/*}
[[ -z $func ]] || [[ -z $offset ]] || [[ $func = $func_offset ]] ||
	[[ $offset = $func_offset ]] && die "bad func+offset $func_offset"

command -v objdump >/dev/null 2>&1 || die "objdump isn't installed"
command -v addr2line >/dev/null 2>&1 || die "addr2line isn't installed"

addrs=$(objdump -t $objfile | awk -v f=$func '$6 == f {print $1}')
[[ -z $addrs ]] && die "can't find $func in $objfile"

for base in $addrs; do
	addr=$((0x$base + $offset))
	[[ -z $addr ]] || [[ $addr = 0 ]] && die "bad address: 0x$base + $offset"

	hexaddr=$(printf %x $addr)
	addr2line -ie $objfile $hexaddr
done
