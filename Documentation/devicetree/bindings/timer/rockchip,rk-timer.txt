Rockchip rk timer

Required properties:
- compatible: shall be one of:
  "rockchip,rk3288-timer" - for rk3066, rk3036, rk3188, rk322x, rk3288, rk3368
  "rockchip,rk3399-timer" - for rk3399
- reg: base address of the timer register starting with TIMERS CONTROL register
- interrupts: should contain the interrupts for Timer0
- clocks : must contain an entry for each entry in clock-names
- clock-names : must include the following entries:
  "timer", "pclk"

Note:
If device tree contain only one timer, than the timer will be intialized
as clockevent provider. If device tree contain two timers, than first timer
will be initialized as clockevent provider and second one as clocksource.

If you want to bind specific timer as clockevent (i.e. one from alive subsystem)
and specific timer as clocksource, you can number the timers in "aliases" node.

If device tree contain only one timer and the timer is named as timer1 in
"aliases" node, then the timer will be initialized as clocksource.

Example (clockevent only):
	timer: timer@ff810000 {
		compatible = "rockchip,rk3288-timer";
		reg = <0xff810000 0x20>;
		interrupts = <GIC_SPI 72 IRQ_TYPE_LEVEL_HIGH>;
		clocks = <&xin24m>, <&cru PCLK_TIMER>;
		clock-names = "timer", "pclk";
	};

Example (clockevent and clocksource with explicit numbering):
	aliases {
		timer0 = &timer6;
		timer1 = &timer5;
	};

	timer5: timer@20038080 {
		compatible = "rockchip,rk3188-timer", "rockchip,rk3288-timer";
		reg = <0x20038080 0x20>;
		interrupts = <GIC_SPI 60 IRQ_TYPE_LEVEL_HIGH>;
		clocks = <&cru SCLK_TIMER5>, <&cru PCLK_TIMER0>;
		clock-names = "timer", "pclk";
	};

	timer6: timer@200380A0 {
		compatible = ""rockchip,rk3188-timer", rockchip,rk3288-timer";
		reg = <0x200380A0 0x20>;
		interrupts = <GIC_SPI 64 IRQ_TYPE_LEVEL_HIGH>;
		clocks = <&cru SCLK_TIMER6>, <&cru PCLK_TIMER0>;
		clock-names = "timer", "pclk";
	};
