				RDMA Controller
				----------------

Contents
--------

1. Overview
  1-1. What is RDMA controller?
  1-2. Why RDMA controller needed?
  1-3. How is RDMA controller implemented?
2. Usage Examples

1. Overview

1-1. What is RDMA controller?
-------------------------------------

RDMA controller allows user to limit RDMA/IB specific resources
that a given set of processes can use. These processes are grouped using
RDMA controller.

RDMA controller currently allows two different type of resource
pools.
(a) RDMA IB specification level verb resources defined by IB stack
(b) HCA vendor device specific resources

RDMA controller controller allows maximum of upto 64 resources in
a resource pool which is the internal construct of rdma cgroup explained
at later part of this document.

1-2. Why RDMA controller needed?
----------------------------------------

Currently user space applications can easily take away all the rdma device
specific resources such as AH, CQ, QP, MR etc. Due to which other applications
in other cgroup or kernel space ULPs may not even get chance to allocate any
rdma resources. This leads to service unavailability.

Therefore RDMA controller is needed through which resource consumption
of processes can be limited. Through this controller various different rdma
resources described by IB uverbs layer and any HCA vendor driver can be
accounted.

1-3. How is RDMA controller implemented?
------------------------------------------------

RDMA cgroup allows limit configuration of resources. These resources are not
defined by the rdma controller. Instead they are defined by the IB stack
and HCA device drivers(optionally).
This provides great flexibility to allow IB stack to define new resources,
without any changes to rdma cgroup.
Rdma cgroup maintains resource accounting per cgroup, per device, per resource
type using resource pool structure. Each such resource pool is limited up to
64 resources in given resource pool by rdma cgroup, which can be extended
later if required.

This resource pool object is linked to the cgroup css. Typically there
are 0 to 4 resource pool instances per cgroup, per device in most use cases.
But nothing limits to have it more. At present hundreds of RDMA devices per
single cgroup may not be handled optimally, however there is no known use case
for such configuration either.

Since RDMA resources can be allocated from any process and can be freed by any
of the child processes which shares the address space, rdma resources are
always owned by the creator cgroup css. This allows process migration from one
to other cgroup without major complexity of transferring resource ownership;
because such ownership is not really present due to shared nature of
rdma resources. Linking resources around css also ensures that cgroups can be
deleted after processes migrated. This allow progress migration as well with
active resources, even though that’s not the primary use case.

Whenever RDMA resource charing occurs, owner rdma cgroup is returned to
the caller. Same rdma cgroup should be passed while uncharging the resource.
This also allows process migrated with active RDMA resource to charge
to new owner cgroup for new resource. It also allows to uncharge resource of
a process from previously charged cgroup which is migrated to new cgroup,
even though that is not a primary use case.

Resource pool object is created in following situations.
(a) User sets the limit and no previous resource pool exist for the device
of interest for the cgroup.
(b) No resource limits were configured, but IB/RDMA stack tries to
charge the resource. So that it correctly uncharge them when applications are
running without limits and later on when limits are enforced during uncharging,
otherwise usage count will drop to negative. This is done using default
resource pool. Instead of implementing any sort of time markers, default pool
simplifies the design.

Resource pool is destroyed if it was of default type (not created
by administrative operation) and it’s the last resource getting
deallocated. Resource pool created as administrative operation is not
deleted, as it’s expected to be used in near future.

If user setting tries to delete all the resource limit
with active resources per device, RDMA cgroup just marks the pool as
default pool with maximum limits for each resource, otherwise it deletes the
default resource pool.

2. Usage Examples
-----------------

(a) Configure resource limit:
echo mlx4_0 mr=100 qp=10 ah=2 > /sys/fs/cgroup/rdma/1/rdma.verb.max
echo ocrdma1 mr=120 qp=20 cq=10 > /sys/fs/cgroup/rdma/2/rdma.verb.max

(b) Query resource limit:
cat /sys/fs/cgroup/rdma/2/rdma.verb.max
#Output:
mlx4_0 mr=100 qp=10 ah=2
ocrdma1 mr=120 qp=20 cq=10

(c) Query current usage:
cat /sys/fs/cgroup/rdma/2/rdma.verb.current
#Output:
mlx4_0 mr=95 qp=8 ah=2
ocrdma1 mr=0 qp=20 cq=10

(d) Delete resource limit:
echo mlx4_0 remove > /sys/fs/cgroup/rdma/1/rdma.verb.max

(e) Configure hw specific resource limit: (optional)
echo vendor1 hw_qp=56 > /sys/fs/cgroup/rdma/2/rdma.hw.max
