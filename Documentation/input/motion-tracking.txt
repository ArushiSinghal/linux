                           Motion Tracking API
----------------------------------------------------------------------------

1. Intro
~~~~~~~~
Motion tracking devices produce device motion events generated from an
accelerometer, gyroscope or compass. These data can be returned to user-space
via input events. This document defines how these data are reported.

2. Devices
~~~~~~~~~~
In this document, a "device" is one of:
 - accelerometer
 - gyroscope
 - compass

These devices returned their information via different APIs in the past. To
unify them and define a common API, a set of input evdev codes was created. Old
drivers might continue using their API, but developers are encouraged to use
the input evdev API for new drivers.

2.1 Axes
~~~~~~~~
Movement data is usually returned as absolute data for the 3 axes of a device.
In this context, the three axes are defined in a right-handed coordinate
system as:
 - X: Axis goes from the left to the right side of the device
 - Y: Axis goes from the bottom to the top of the device
 - Z: Axis goes from the back to the front of the device

The front of a device is the side faced to the user. For a mobile-phone it
would be the screen. For devices without a screen, the top is usually the
side with the most buttons on it.

                           Example: Mobile-Phone
  +-------------------------------------------------------------------------+
  |                      TOP                                                |
  |                                                                         |
  |                                                                         |
  |          +---------------------------+                                  |
  |          |\  ________________________ \      .__                        |
  |          \ \ \                       \ \     |\                         |
  |           \ \ \              __       \ \      \                   RIGHT|
  |            \ \ \              /|       \ \      \__                     |
  |             \ \ \          __/          \ \     |\                      |
  |              \ \ \          /|           \ \      \ (Y Axis)            |
  |               \ \ \      __/  (Z axis)    \ \      \__                  |
  |                \ \ \      /|               \ \     |\                   |
  | LEFT            \ \ \    /                  \ \      \                  |
  |                  \ \ \         FRONT         \ \      \                 |
  |                   \ \ \                       \ \                       |
  |                    \ \ \_______________________\ \                      |
  |                     \ \             ___           \                     |
  |                     /\ \            \__\           \                    |
  |                  __/  \ +---------------------------+                   |
  |                   /|   \|___________________________|                   |
  |                  / BACK                                                 |
  |                                      (X axis)                           |
  |                        ------->------->------->------->                 |
  |                                                                         |
  |                                                                         |
  |                                         BOTTOM                          |
  +-------------------------------------------------------------------------+

Rotation-data is reported as counter-clockwise rotation on an axis when viewed
from the top of the axis, as given by the right hand rule. For a given axis,
the reported rotation would be:
                                        ____
                                          //|
                                         // | (axis)
                                        //
                                       //
                                  .   // __
                                 /   // /\
                                |   //    |
                                 \ //    /  (counter-clockwise rotation)
                                  *.___.*
                                 //
                                //

2.2 Calibration
~~~~~~~~~~~~~~~
Motion sensors are often highly sensitive and need precise calibration. Users
are advised to perform neutral-point calibration themselves or to implement a
state-machine to normalize input data automatically.

Kernel devices may perform their own calibration and/or normalization. However,
this is usually sparse and, if implemented, transparent to the user.

There is currently no way to feed calibration data into the kernel in a generic
way. Proposals welcome!

2.3 Units
~~~~~~~~~
(NOTE: This section describes an experimental API. Currently, no device complies
to these rules so this might change in the future.)

Reported data shall be returned as:
 - Acceleration: 1/(input_absinfo.resolution) G
 - Rotation: 1/(input_absinfo.resolution) degree per second

Acceleration is reported in units of G as opposed to m/s^2, because acceleration
sensors internally work based on gravitation. Since the conversion to m/s^2 is
location dependent, applications should either approximate the conversion
factor as 9.8 m/s^2 or if more precision is desired obtain a scaling factor
by other means e.g. GPS.

However, for most devices the reported units are unknown (more precisely: no
one has the time to measure them and figure them out). Therefore, user-space
shall use abs-minimum and abs-maximum to calculate relative data and use that
instead. Devices which return wrong units may be fixed in the future to comply
to these rules.

2.4 Timestamps
~~~~~~~~~~~~~~
For motion tracking purposes the time delta between consecutive motion events
is important for mathematical operations such as differentiation and integration.
The time delta could be derived from the 'time' field in 'struct input_event' by
subtracting the time between consecutive events. However, this timestamp may not
provide enough accuracy depending on the use case, since it is based upon time of
processing within the input layer versus time of arrival in the kernel or the
time the hardware sent the data. There is often a small variable time difference
between these.

Optionally, hardware may provide a hardware timestamp produced at the time it
sampled the motion sensors. This timestamp is is exposed through
'MSC_TIMESTAMP' event, which provides timing information in microseconds.
If available, MSC_TIMESTAMP is the recommended approach for calculation of time
deltas.

3.1 Accelerometer
~~~~~~~~~~~~~~~~~
Accelerometers measure movement acceleration of devices. Any combination of the
three available axes can be used. Usually, all three are supported.

Data is provided as absolute acceleration. A positive integer defines the
acceleration in the direction of an axis. A negative integer defines
acceleration in the opposite direction.

The evdev ABS codes used are:
 - ABS_ACCEL_X: X axis
 - ABS_ACCEL_Y: Y axis
 - ABS_ACCEL_Z: Z axis

3.2 Gyroscope
~~~~~~~~~~~~~
A gyroscope measures rotational speed (*not* acceleration!). Any combination of
the three available axes can be used. Usually, all three are supported.

Data is provided as absolute speed. A positive integer defines the rotational
speed in counter-clockwise order around a given axis when viewed from the top of
the axis. A negative integer defines it in clockwise order.

The evdev ABS codes used are:
 - ABS_GYRO_X: X axis (also: Pitch)
 - ABS_GYRO_Y: Y axis (also: Roll)
 - ABS_GYRO_Z: Z axis (also: Azimuth/Yaw)

3.3 Compass
~~~~~~~~~~~
(NOTE: No compass device currently uses the evdev input subsystem. Thus, this
API is only a proposal, it hasn't been implemented, yet.)

A compass measures the ambient magnetic field of the three defined axes. This
makes the data self-contained and independent of the current device position.
Any combination of the three axes can be used. Usually all three are supported,
otherwise, it's not really useful as a compass.

Proposed evdev ABS codes are:
 - ABS_COMPASS_X: X axis
 - ABS_COMPASS_Y: Y axis
 - ABS_COMPASS_Z: Z axis

----------------------------------------------------------------------------
  (c) 2013 David Herrmann <dh.herrmann at gmail.com>
  (c) 2016 Roderick Colenbrander <roderick.colenbrander@sony.com>
